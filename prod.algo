PROCEDURE dot_product(v1[]:INTEGER,v2[]:INTEGER)
VAR
    ps:INTEGER
    i:INTEGER
BEGIN
   
    FOR i <i=0; i<=v1.length; i++>  DO 
    ps <-- ps+( v1[i] * v2[i])
      END_FOR 
END





FUNCTION dot-product(v1[] : ARRAY_OF INTEGER;,v2[] : ARRAY_OF INTEGER[]) : INTEGER
VAR
    ps:INTEGER
    i,j:INTEGER
BEGIN
     ps = 0;
    for( i = 0; i < v1.length; i++){
        ps <-- ps+( v1[i] * v2[j]);
      }
    return ps;

   
    
   END

ALGORITHM algorithm_name
VAR
  
BEGIN

  write("donner l'element",i, "de la vecteur v1"  );
    read(v1(i));
    write("donner l'element",i, "de la vecteur v2"  );
    read(v2(i));
    IF (v1.length!=v2.length) THEN
    write("verifier la longueur")
  dot_product(v1[]:INTEGER,v2[]:INTEGER,ps:INTEGER)
      IF (ps=0) THEN
        write("les 2 vecteurs sont orthogonaux")
        else 
        write("les 2 vecteurs ne sont pas orthogonaux")
      END_IF
    END_IF
END
   

ALGORITHM orthogonaux-vec
VAR
  
BEGIN

  write("donner l'element",i, "de la vecteur v1"  );
    read(v1(i));
    write("donner l'element",i, "de la vecteur v2"  );
    read(v2(i));
    IF (v1.length!=v2.length) THEN
    write("verifier la longueur")
  p0:= dot_product(v1[]:INTEGER,v2[]:INTEGER)
      IF (p0=0) THEN
        write("les 2 vecteurs sont orthogonaux")
        else 
        write("les 2 vecteurs ne sont pas orthogonaux")
      END_IF
    END_IF
END


 